1. FTPClient
	连接时需要生成socket，并得到inputstream/outputsteam 并用BufferedReader/BufferedWriter进行包装(write后别忘了flush, 之后需要判断 _socket_.isConnected();是否socket是connect状态)
   FTPServer在成功建立后需要向客户端发送 200 New Session established.（我发现socket都是通过javax.net.ServerSocketFactory.createServerSocket(int, int, InetAddress)创建socket的??????）
   FTPClient进行解析，包括状态码和后面的消息
   	    之后进行用户认证，先发送username，服务端会返回 331 User name okay, need password for juno.
   发送前，服务器确认文件状态，是否存在？
	150 File status okay; about to open data connection.
   发送中，没啥特殊的就是BufferedReader反复读取收据内容
   发送后，服务器发送状态码表示发送成功



3. Lambda -》 stream（）
Set<String> idSet
List<Long> ids = idSet.stream().map(Long::parseLong).collect(Collectors.toList())


for循环
https://www.hackerrank.com/challenges/strange-advertising/problem?h_r=profile

字符串操作
前置知识： java.lang.String.indexOf(String, int)
	   java.lang.String.substring(int, int)
	   StringBuilder  append("sss")/toString()
https://www.hackerrank.com/challenges/the-grid-search/problem?h_r=profile


List
https://www.hackerrank.com/challenges/grading/problem




org.springframework.aop.aspectj.annotation.BeanFactoryAspectJAdvisorsBuilder.buildAspectJAdvisors()

！！！！！！！！！！！！！！！！！！！
在Spring中，所有bean实例化时都会保证其调用org.springframework.aop.framework.autoproxy.AbstractAutoProxyCreator.postProcessAfterInitialization(Object, String)
来判断返回bean还是其代理类的实例



解析@Transactional注解
org.springframework.transaction.annotation.SpringTransactionAnnotationParser.parseTransactionAnnotation(AnnotatedElement)

Collections.singleton(annotationType) : Collections.emptySet()



map.computeIfAbsent

Spring事务搜索
org.springframework.transaction.interceptor.AbstractFallbackTransactionAttributeSource.computeTransactionAttribute(Method, Class<?>)
对于 务属性的获取规则相信大家都已经很清楚，如果方法中存在事务属性，则使用方法
上的属性，否则使用方法所在的类上的属性，如果方法所在类的属性上还是没有搜寻到对应的
务属性，那么再搜寻接口中的方法，再没有的话，最后尝试搜 接口的类上面的声明



事务传播行为类型

说明

PROPAGATION_REQUIRED

如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。这是最常见的选择。

PROPAGATION_SUPPORTS

支持当前事务，如果当前没有事务，就以非事务方式执行。

PROPAGATION_MANDATORY

使用当前的事务，如果当前没有事务，就抛出异常。

PROPAGATION_REQUIRES_NEW

新建事务，如果当前存在事务，把当前事务挂起。

PROPAGATION_NOT_SUPPORTED

以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。

PROPAGATION_NEVER

以非事务方式执行，如果当前存在事务，则抛出异常。

PROPAGATION_NESTED

如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。

检查某个类是当前接口/类的子类 XXXXXX.class.isAssignableFrom



事务挂起 org.springframework.transaction.support.AbstractPlatformTransactionManager.suspend


对于当前是否有事务，spring的判断及其简单，通过ConnectionHolder的变量，每次提交sql前设为true
private boolean transactionActive = false;

声明式事务、编程式事务

将信息绑定给线程的方式，可以写一个工具类，里面都是静态的ThreadLocal，
如 private static final ThreadLocal<Boolean> currentTransactionReadOnly =
			new NamedThreadLocal<>("Current transaction read-only status");
其中NamedThreadLocal继承ThreadLocal，但是添加一个private final String name;用来记载该ThreadLocal对象的用途

事务debug入口
-------> TransactionAspectSupport.prepareTransactionInfo

ServletContextListen 中的核心逻辑便是初始化 WebApplication Context 实例并存放至ServletContainer 中

Spring源码
E:\百度网盘 	springboot教程 & 房产微服务
Angular



http://localhost:8080/servlet/ModernServlet?userName=tarzan&password=pwd


浏览器请求第一行
GET /myApp/ModernServlet?userName=tarzan&password=pwd HTTP/1.1

浏览器发送Cookie例子
Cookie: userName=budi; password=pwd;



对于 Catalina 的容器首先需要注意的是它一共有四种不同的容器：
· Engine：表示整个 Catalina 的 servlet 引擎
· Host：表示一个拥有数个上下文的虚拟主机
· Context：表示一个 Web 应用，一个 context 包含一个或多个
wrapper
· Wrapper：表示一个独立的 servlet


从流中加载类
java.security.SecureClassLoader.defineClass(String, byte[], int, int, CodeSource)
tomcat获取类加载器步骤1， 从本地缓存map中获取 2.从parent加载器的缓存中获取（是jdk classloader的一个本地方法）java.lang.ClassLoader.findLoadedClass(String)
3。获取system的加载器，通过调用方法java.lang.ClassLoader.getSystemClassLoader()



    /**
     * Load the class with the specified name, searching using the following
     * algorithm until it finds and returns the class.  If the class cannot
     * be found, returns <code>ClassNotFoundException</code>.
     * <ul>
     * <li>Call <code>findLoadedClass(String)</code> to check if the
     *     class has already been loaded.  If it has, the same
     *     <code>Class</code> object is returned.</li>
     * <li>If the <code>delegate</code> property is set to <code>true</code>,
     *     call the <code>loadClass()</code> method of the parent class
     *     loader, if any.</li>
     * <li>Call <code>findClass()</code> to find this class in our locally
     *     defined repositories.</li>
     * <li>Call the <code>loadClass()</code> method of our parent
     *     class loader, if any.</li>
     * </ul>
     * If the class was found using the above steps, and the
     * <code>resolve</code> flag is <code>true</code>, this method will then
     * call <code>resolveClass(Class)</code> on the resulting Class object.
     *
     * @param name Name of the class to be loaded
     * @param resolve If <code>true</code> then resolve the class
     *
     * @exception ClassNotFoundException if the class was not found
     */
    public Class loadClass(String name, boolean resolve)
        throws ClassNotFoundException {
        if (debug >= 2)
            log("loadClass(" + name + ", " + resolve + ")");
        Class clazz = null;

        // Don't load classes if class loader is stopped
        if (!started) {
            log("Lifecycle error : CL stopped");
            throw new ClassNotFoundException(name);
        }

        // (0) Check our previously loaded local class cache
        clazz = findLoadedClass0(name);
        if (clazz != null) {
            if (debug >= 3)
                log("  Returning class from cache");
            if (resolve)
                resolveClass(clazz);
            return (clazz);
        }

        // (0.1) Check our previously loaded class cache
        clazz = findLoadedClass(name);
        if (clazz != null) {
            if (debug >= 3)
                log("  Returning class from cache");
            if (resolve)
                resolveClass(clazz);
            return (clazz);
        }

        // (0.2) Try loading the class with the system class loader, to prevent
        //       the webapp from overriding J2SE classes
        try {
            clazz = system.loadClass(name);
            if (clazz != null) {
                if (resolve)
                    resolveClass(clazz);
                return (clazz);
            }
        } catch (ClassNotFoundException e) {
            // Ignore
        }

        // (0.5) Permission to access this class when using a SecurityManager
        if (securityManager != null) {
            int i = name.lastIndexOf('.');
            if (i >= 0) {
                try {
                    securityManager.checkPackageAccess(name.substring(0,i));
                } catch (SecurityException se) {
                    String error = "Security Violation, attempt to use " +
                        "Restricted Class: " + name;
                    System.out.println(error);
                    se.printStackTrace();
                    log(error);
                    throw new ClassNotFoundException(error);
                }
            }
        }

        boolean delegateLoad = delegate || filter(name);

        // (1) Delegate to our parent if requested
        if (delegateLoad) {
            if (debug >= 3)
                log("  Delegating to parent classloader");
            ClassLoader loader = parent;
            if (loader == null)
                loader = system;
            try {
                clazz = loader.loadClass(name);
                if (clazz != null) {
                    if (debug >= 3)
                        log("  Loading class from parent");
                    if (resolve)
                        resolveClass(clazz);
                    return (clazz);
                }
            } catch (ClassNotFoundException e) {
                ;
            }
        }

        // (2) Search local repositories
        if (debug >= 3)
            log("  Searching local repositories");
        try {
            clazz = findClass(name);
            if (clazz != null) {
                if (debug >= 3)
                    log("  Loading class from local repository");
                if (resolve)
                    resolveClass(clazz);
                return (clazz);
            }
        } catch (ClassNotFoundException e) {
            ;
        }

        // (3) Delegate to parent unconditionally
        if (!delegateLoad) {
            if (debug >= 3)
                log("  Delegating to parent classloader");
            ClassLoader loader = parent;
            if (loader == null)
                loader = system;
            try {
                clazz = loader.loadClass(name);
                if (clazz != null) {
                    if (debug >= 3)
                        log("  Loading class from parent");
                    if (resolve)
                        resolveClass(clazz);
                    return (clazz);
                }
            } catch (ClassNotFoundException e) {
                ;
            }
        }

        // This class was not found
        throw new ClassNotFoundException(name);

    }



tomcat检查session过期的后台线程 org.apache.catalina.session.StandardManager.processExpires()
